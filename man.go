package king

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/alecthomas/kong"
)

// Man is a manual page generator.
type Man struct {
	name      string
	Section   int // See mmark's documentation
	Area      string
	WorkGroup string
	Template  string // If empty [ManTemplate] is used.
	manual    []byte
	Flags     []*kong.Flag // Any global flags that the should Application Node have. There are documented after the normal options.
}

// ManTemplate is the default manual page template used when generating a manual page. Where each function
// used is:
//
//   - name: generate a <cmdname> - <single line synopsis>. The node's help is used for this.
//   - synopsis: shows the argument and options. If the node has aliases they are shown here as well.
//   - description: the description of the command's function. The node (non-Kong) "description" tag is used for
//     this.
//   - arguments: a rundown of each of the commands and/or arguments this command has.
//   - options: a list documenting each of the options.
//   - globals: any global flags, from m.Flags.
const ManTemplate = `{{name -}}

{{synopsis -}}

{{description -}}

{{arguments -}}

{{options -}}

{{globals -}}
`

// Out returns the manual in markdown form.
func (m *Man) Out() []byte { return m.manual }

// Write writes the manual page in man format to the file m.name.m.section.
func (m *Man) Write() error {
	if m.manual == nil {
		return fmt.Errorf("no manual")
	}
	// convert to manpage.
	return os.WriteFile(fmt.Sprintf("%s.%d", m.name, m.Section), m.manual, 0644)
}

// name implements the template func name.
func name(k, cmd *kong.Node) string {
	help := strings.TrimSuffix(cmd.Help, ".")
	return fmt.Sprintf("## Name\n\n%s %s - %s\n\n", k.Name, cmd.Name, help)
}

// Manual generates a manual page for field named name of the node.
// On the node k the following tags are used:
//
//   - cmd:"....": command name, overrides k.<named>.Name
//   - aliases:"...": any extra names that this command has.
//   - help:"...": line used in the NAME section: "cmd" - "help" text, as in "ls - list directory contents" if
//     this text ends in a dot it is removed.
//   - description:".....": The entire description paragraph.
//
// Note that any of these may contain markdown markup. The node k doesn't need any special tags.
func (m *Man) Manual(k *kong.Node, exe string) { // add a field?
	var cmd *kong.Node
	for _, c := range k.Children {
		if c.Name == exe {
			cmd = c
			break
		}
	}
	// k.Name is exe, field is what we need
	// m.name is exe
	if cmd == nil {
		log.Printf("Failed to generate manual page: %q not found as child", exe)
		return
	}
	fmt.Printf("%+v\n", cmd)
	for _, c := range cmd.Children {
		println(c.Name)
	}

	funcMap := template.FuncMap{
		"name":        func() string { return name(k, cmd) },
		"description": func() string { return cmd.Tag.Get("description") },
		"synopsis":    func() string { return "" },
		"arguments":   func() string { return "" },
		// commands?
		"options": func() string { return "" },
		"globals": func() string { return "" },
	}

	if m.Template == "" {
		m.Template = ManTemplate
	}

	tmpl := &template.Template{}
	var err error

	tmpl = template.New("generated").Funcs(funcMap)
	tmpl, err = tmpl.Parse(m.Template)
	if err != nil {
		log.Printf("Failed to generate manual page: %s", err)
		return
	}

	format := `%%%%%%
title = "%s %d"
area = "%s"
workgroup = "%s"
# generated by king completion (https://github.com/miekg/king) for kong
%%%%%%

`
	b := &bytes.Buffer{}
	fmt.Fprintf(b, format, cmd.Name, m.Section, m.Area, m.WorkGroup)
	if err = tmpl.Execute(b, nil); err != nil {
		log.Printf("Failed to generate manual page: %s", err)
		return
	}
	m.manual = b.Bytes()
}

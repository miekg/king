package king

import (
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/alecthomas/kong"
)

// Zsh is a zsh completion generator.
type Zsh struct {
	name       string
	completion []byte
	Flags      []*kong.Flag // Any global flags that the should Application Node have.
}

func (z *Zsh) Out() []byte { return z.completion }

// Write writes the completion in z to the file "_" + z.name.
func (z *Zsh) Write() error {
	if z.completion == nil {
		return fmt.Errorf("no completion")
	}
	return os.WriteFile("_"+z.name, z.completion, 0644)
}

// Completion generates a zsh compatible completion. The name is used as the name of the command for which
// the completion should be generated, usually this can be just kong.Model.Name.
func (z *Zsh) Completion(k *kong.Node, name string) {
	k.Flags = append(k.Flags, z.Flags...)

	format := `#compdef %[1]s
compdef _%[1]s %[1]s
# zsh completion for %[1]s
# generated by king completion (https://github.com/miekg/king) for kong

`
	var out strings.Builder
	fmt.Fprintf(&out, format, name)
	z.name = name
	k.Name = name
	z.gen(&out, k)
	z.completion = []byte(out.String())
}

func (z Zsh) writeFlag(buf io.StringWriter, f *kong.Flag) {
	var str strings.Builder
	str.WriteString("        ")
	if f.Short != 0 {
		str.WriteString("'(")
		str.WriteString(fmt.Sprintf("-%c --%s", f.Short, f.Name))
		if !f.IsBool() {
			str.WriteString("=")
		}
		str.WriteString(")'")
		str.WriteString("{")
		str.WriteString(fmt.Sprintf("-%c,--%s", f.Short, f.Name))
		if !f.IsBool() {
			str.WriteString("=")
		}
		str.WriteString("}")
		str.WriteString("\"")
	} else {
		str.WriteString("\"")
		str.WriteString(fmt.Sprintf("--%s", f.Name))
		if !f.IsBool() {
			str.WriteString("=")
		}
	}
	str.WriteString(fmt.Sprintf("[%s]", f.Help))
	if !f.IsBool() {
		str.WriteString(":")
		str.WriteString(strings.ToLower(f.Help))
		str.WriteString(":")
	}
	// todo: env flags
	values := flagEnums(f)
	if len(values) > 0 {
		str.WriteString("(")
		for i, v := range f.EnumSlice() {
			str.WriteString(v)
			if i < len(values)-1 {
				str.WriteString(" ")
			}
		}
		str.WriteString(")")
	}
	str.WriteString("\"")
	writeString(buf, str.String())
}

func (z Zsh) writeFlags(buf io.StringWriter, cmd *kong.Node) {
	for i, f := range cmd.Flags {
		if f.Hidden {
			continue
		}
		z.writeFlag(buf, f)
		if i < len(cmd.Flags)-1 {
			writeString(buf, " \\\n")
		}
	}
}

func (z Zsh) writePositional(buf io.StringWriter, cmd *kong.Node) {
	// '1: : _values "<name>" $(c volume-server list --comp)'  -- when there is completion
	// '2:yubikey:' -- when there is no completion, this is the name of the node.
	for i, p := range cmd.Positional {
		if completion(p, "zsh") == "" {
			writeString(buf, fmt.Sprintf("        \"%d:%s:\"", i+1, strings.ToLower(p.Name)))
		} else {
			writeString(buf, fmt.Sprintf("        '%d: : _values \"%s\" %s'", i+1, p.Name, completion(p, "zsh")))
		}
		if i < len(cmd.Positional)-1 {
			writeString(buf, " \\\n")
		}
	}
}

func (z Zsh) writeCommand(buf io.StringWriter, c *kong.Node) {
	writeString(buf, fmt.Sprintf("                \"%s[%s]\"", c.Name, c.Help))
}

func (z Zsh) writeCommands(buf io.StringWriter, cmd *kong.Node) {
	for i, c := range cmd.Children {
		if c == nil || c.Hidden {
			continue
		}
		for _, a := range c.Aliases {
			z.writeCommand(buf, &kong.Node{Name: a, Help: c.Help})
			buf.WriteString(" \\\n")
		}
		z.writeCommand(buf, c)
		if i < len(cmd.Children)-1 {
			buf.WriteString(" \\")
		}
		writeString(buf, "\n")
	}
}

func (z Zsh) gen(buf io.StringWriter, cmd *kong.Node) {
	for _, c := range cmd.Children {
		if c == nil || c.Hidden {
			continue
		}
		z.name = ""
		z.gen(buf, c)
	}
	cmdName := commandName(cmd)

	if z.name != "" {
		writeString(buf, fmt.Sprintf("_%s() {\n", z.name))
	} else {
		writeString(buf, fmt.Sprintf("_%s() {\n", cmdName))
	}
	if hasCommands(cmd) {
		writeString(buf, "    local line state\n")
	}
	writeString(buf, "    _arguments -S -C -s\\\n")
	z.writeFlags(buf, cmd)
	if hasPositional(cmd) {
		writeString(buf, " \\\n")
	}
	z.writePositional(buf, cmd)
	if hasCommands(cmd) {
		writeString(buf, " \\\n")
		writeString(buf, "        \"1: :->cmds\" \\\n")
		writeString(buf, "        \"*::arg:->args\"\n")
		writeString(buf, "    case \"$state\" in\n")
		writeString(buf, "        cmds)\n")
		writeString(buf, fmt.Sprintf("            _values \"%s command\" \\\n", cmdName))
		z.writeCommands(buf, cmd)
		writeString(buf, "            ;;\n")
		writeString(buf, "        args)\n")
		writeString(buf, "            case \"$line[1]\" in\n")
		for _, c := range cmd.Children {
			if c == nil || c.Hidden {
				continue
			}
			for _, a := range c.Aliases {
				writeString(buf, fmt.Sprintf("                %s)\n", a))
				writeString(buf, fmt.Sprintf("                    _%s;;\n", commandName(c)))
			}
			writeString(buf, fmt.Sprintf("                %s)\n", c.Name))
			writeString(buf, fmt.Sprintf("                    _%s;;\n", commandName(c)))
		}
		writeString(buf, "            esac\n")
		writeString(buf, "            ;;\n")
		writeString(buf, "    esac\n")
	}
	writeString(buf, "\n")
	writeString(buf, "}\n\n")
}

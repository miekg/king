package king

import (
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/alecthomas/kong"
)

// Bash is a bash completion generator.
type Bash struct {
	k          *kong.Node
	name       string
	completion []byte
}

// Write writes the completion to file b.name".bash".
func (b *Bash) Write() error {
	if b.k == nil {
		return fmt.Errorf("no kong node")
	}
	if b.completion == nil {
		return fmt.Errorf("no completion")
	}
	return os.WriteFile(b.name+".bash", b.completion, 0644)
}

func (b *Bash) Completion(k *kong.Node, name string) {
	format := `# bash completion for %[1]s
# generated by king completion (https://github.com/miekg/king)

`
	var out strings.Builder
	fmt.Fprintf(&out, format, name)
	b.gen(&out, k, name)
	b.completion = []byte(out.String())
	b.k = k
	b.name = name
}

func (b Bash) writeFilterFunc(buf io.StringWriter, name string) {
	format := `_%[1]s_completions_filter() {
  COMP_REPLY=()
  local words="$1"
  local cur=${COMP_WORDS[COMP_CWORD]}
  local result=()

  if [[ "${cur:0:1}" == "-" ]]; then
    echo "$words"

  else
    for word in $words; do
      [[ "${word:0:1}" != "-" ]] && result+=("$word")
    done
    echo "${result[*]}"
  fi
}
`
	writeString(buf, fmt.Sprintf(format, name))
}

func (b Bash) writeCommands(cmd *kong.Node) {
	// get a list of all commands possible with the longest chains first, so the case works.
}

func (b Bash) gen(buf io.StringWriter, cmd *kong.Node, name string) {
	b.writeFilterFunc(buf, name)
	if hasCommands(cmd) {
		b.writeCommands(cmd)
	}
}

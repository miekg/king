package king

import (
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/alecthomas/kong"
)

// Fish is a fish shell completion generator.
type Fish struct {
	name       string
	completion []byte
	Flags      []*kong.Flag // Any global flags that the should Application Node have.
}

func (f *Fish) Out() []byte { return f.completion }

func (f *Fish) Write(w ...io.Writer) error {
	if f.completion == nil {
		return fmt.Errorf("no completion")
	}
	if len(w) > 0 {
		w[0].Write(f.completion)
	}
	return os.WriteFile(f.name+".fish", f.completion, 0644) // no idea what fish needs
}

func (f *Fish) Completion(k *kong.Node, altname string) {
	k.Flags = append(k.Flags, f.Flags...)

	format := `# fish shell completion for %[1]s
# generated by king (https://github.com/miekg/king) for kong
`

	var out strings.Builder
	if altname == "" {
		f.name = k.Name
	} else {
		f.name = altname
		k.Name = altname
	}
	fmt.Fprintf(&out, format, f.name)
	f.gen(&out, k)
	f.completion = []byte(out.String())
}

func (f Fish) gen(buf io.StringWriter, cmd *kong.Node) {
	root := cmd
	for root.Parent != nil {
		root = root.Parent
	}
	rootName := root.Name
	if cmd.Parent == nil {
		buf.WriteString(fmt.Sprintf("# %s\n", rootName))
	} else {
		buf.WriteString(fmt.Sprintf("# %s\n", cmd.Path()))
		buf.WriteString(fmt.Sprintf("complete -c %s -f -n '__fish_use_subcommand' -a %s -d '%s'\n", rootName, cmd.Name, cmd.Help))
	}

	for _, f := range cmd.Flags {
		if f.Hidden {
			continue
		}
		if cmd.Parent == nil {
			buf.WriteString(fmt.Sprintf("complete -c %s -f", rootName))
		} else {
			buf.WriteString(fmt.Sprintf("complete -c %s -f -n '__fish_seen_subcommand_from %s'", rootName, cmd.Name))
		}
		if !f.IsBool() {
			enums := flagEnums(f)
			if len(enums) > 0 {
				buf.WriteString(fmt.Sprintf(" -xa '%s'", strings.Join(enums, " ")))
			} else {
				buf.WriteString(" -x")
			}
		}
		if f.Short != 0 {
			buf.WriteString(fmt.Sprintf(" -s %c", f.Short))
		}
		buf.WriteString(fmt.Sprintf(" -l %s", f.Name))
		buf.WriteString(fmt.Sprintf(" -d \"%s\"", f.Help))
		buf.WriteString("\n")
	}
	buf.WriteString("\n")

	for _, c := range cmd.Children {
		if c == nil || c.Hidden {
			continue
		}
		f.gen(buf, c)
	}
}
